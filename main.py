from sqlalchemy import create_engine, Column, Integer, String #creat engine for database to communicate with appliation
from sqlalchemy.orm import sessionmaker, Session #session and sessionsmaker for operating database 
from sqlalchemy.ext.declarative import declarative_base #base class for sql model
from fastapi import Depends, FastAPI, HTTPException #imports FASTAPI, exception handler and Depends from fastapi
from pydantic import BaseModel, field_validator, ValidationError #imports pydantic model and field validations 
from typing import List, Optional #import for listing and optional data 

#SQLAlchemy connection setup---------------------------------
URL_DATABASE = 'mysql://root:N0!problem@localhost:3306/bookapp' #link to connect to my sql database

engine = create_engine(URL_DATABASE, connect_args={"charset": "utf8mb4"}) #created engine with charset

SessionLocal= sessionmaker(autocommit=False, autoflush=False, bind=engine) #creates session factory for managing DB sessions
#end of SQLAlchey setup---------------------------------------


#Data MODEL ------------------------------------------------------
Base = declarative_base() #base class for defining sql model


class Books(Base): #data model for Books 
    __tablename__ = 'books' #table name 

    id = Column(Integer, primary_key=True, index=True) #primary key column with an index
    bookname=Column(String(500), nullable=False) #Book Name column, cannot be null
    authorname=Column(String(255),nullable=False) #Author name column, cannot be null
    yearpublished=Column(Integer,nullable=False) #year published column, cannot be null
    genre=Column(String(100),nullable=False) #genre column, cannot be null
    copies=Column(Integer,nullable=False) # number of copies column, cannot be null

#end of Data MOdel--------------------------------------------

app = FastAPI() #creates fastapi instance

#dependency to get DB session
def get_db():
    db = SessionLocal() # creates a new session
    try:
        yield db  #yields new session to endpoint function
    finally:
        db.close() #closes session after request


#Pydantic Validation for Books ------------
class BookCreate(BaseModel): # basically the class initalizer for books 
    bookname: str #book name field 
    authorname: str #author name field
    yearpublished:int #year published field
    genre:str #genre field
    copies:int #number of copies field

    @field_validator("yearpublished") #validation for year published
    def validateYear(cls, value): #takes in year value 
        if len(str(value)) != 4: # ensure that the year is a length of 4 digits
            raise ValueError("Year must be 4 digits") #returns an error message if not 4 digits
        return value #returns value if validated

class BookOut(BookCreate): #imports BookCreate class and adds on auto generated id number by mysql to return full information of book in myql
    id: int #bookid field (aut generated by mysql)

    class Config:
        orm_mode = True #enables automatic conversion of ORM objects to dict

class BookUpdate(BaseModel): # used for updating specific fields for books -- does not need to include all fields 
    bookname: Optional[str] = None #book name field optional - does not need to be specified if not updating
    authorname: Optional[str] = None  #author name field optional - does not need to be specified if not updating 
    yearpublished:Optional[int] = None  #year published field optional - does not need to be specified if not updating
    genre:Optional[str] = None  #genre field optional - does not need to be specified if not updating
    copies:Optional[int] = None  #number of copies field optional - does not need to be specified if not updating

    #same validation rules as in BookCreate
    @field_validator("yearpublished") #validation for year published
    def validateYear(cls, value): #takes in year value 
        if len(str(value)) != 4: # ensure that the year is a length of 4 digits
            raise ValueError("Year must be 4 digits") #returns an error message if not 4 digits
        return value #returns value if validated

#end of Pydantic Validation -----------------------------------------------------

#initializes the database 
Base.metadata.create_all(bind=engine) #automatically creates the 'books' table in the database

#routes ------------------------------------------------------------------------------------
@app.get("/books", response_model=List[BookOut]) #route the returns list of books. Response model uses List to list out all of the books using BookOut class
def get_books(db: Session = Depends(get_db)): #retrieves the session to get current db
    books = db.query(Books).all() #queries db to retrieve books
    return books #list out books

@app.get("/books/{bid}", response_model=BookOut) #route the retrives specific book by id number
def get_book(bid:int, db:Session=Depends(get_db)): #converts inputed id number and retrives the session to get current db
    book = db.query(Books).filter(Books.id == bid).first() #queries through list of books and returns the first match to the inputed id number
    if not book:
        raise HTTPException(status_code=404,detail="Book Not Found") #if not book is found, return error message
    return book #returns found book

@app.post("/books", response_model=BookOut) #route that creates new book
def create_book(book: BookCreate, db:Session = Depends(get_db)): #takes inputted data and retrieves database session
    db_book = Books( #creates new instance of book
        bookname = book.bookname, #assign inputted book name to new book oject
        authorname= book.authorname, #assign inputted author name to new book oject
        yearpublished= book.yearpublished, #assign inputted year published to new book oject
        genre= book.genre, #assign inputted genre to new book oject
        copies= book.copies  #assign inputted number of to new book oject
        )
    
    db.add(db_book) #adds new book to the session
    db.commit() #instructs session to save the book to database
    db.refresh(db_book) #refeshes new book to retrieve updated data
    return db_book #returns new book info to usere

@app.put("/books/{bid}", response_model=BookOut) #route the updates existing book -- MUST INCLUDE ALL FIELDS(if found)
def update_book(bid: int, updated_book:BookCreate, db: Session=Depends(get_db)): #takes in book id number, uses bookcreate model to update book, and retrieves current session

    db_book = db.query(Books).filter(Books.id == bid).first() #queries through book table and find first match to given book id number
    if not db_book: #returns an error if book is not found
        raise HTTPException(status_code=404, detail="Book Not Found")
    
    #else if book is found -- it will update fields
 
    db_book.bookname = updated_book.bookname #updates book name
    db_book.authorname = updated_book.authorname #updates author name
    db_book.yearpublished = updated_book.yearpublished #updates year published
    db_book.genre = updated_book.genre #updates book genre
    db_book.copies = updated_book.copies #updates number of copies available


    db.commit() #instructs session to save the book to database
    db.refresh(db_book) #refeshes new book to retrieve updated data
    return db_book  #returns new book info to user

#couldnt figure out how to use put method to only take specified fields in postman so i used patch to bypass the problem
@app.patch('/books/{bid}',response_model=BookOut) #route that updates book by a specified field -- no neeed to include all fields to update book (if found)
def patch_book(bid: int, updated_data: BookUpdate, db: Session = Depends(get_db)): #takes in book id number, uses bookupdate model to update book, and retrieves current session
 # Fetch the existing book from the database
    db_book = db.query(Books).filter(Books.id == bid).first() #queries through book table and find first match to given book id number
    if not db_book: #returns an error if book is not found
        raise HTTPException(status_code=404, detail="Book Not Found")
    
    #updates ONLY speciefed fields that are written by user -- no need to specify EVERY field in request/query
    if updated_data.bookname != None: #updates bookname if given (not empty)
        db_book.bookname = updated_data.bookname #upates book name
    if updated_data.authorname != None: #updates if authorname if given (not empty)
        db_book.authorname = updated_data.authorname #upates author name
    if updated_data.yearpublished != None: #updates if yearpublished if given (not empty)
        db_book.yearpublished = updated_data.yearpublished #upates year published
    if updated_data.genre != None: #updates if genre if given (not empty)
        db_book.genre = updated_data.genre #upates genre
    if updated_data.copies != None: #updates number of copies if given (not empty)
        db_book.copies = updated_data.copies #upates copies

    
    db.commit() #instructs session to save the book to database
    db.refresh(db_book)#refeshes new book to retrieve updated data
    return db_book #returns new book info to user



@app.delete("/books/{bid}") #route that deletes books by given id number 
def delete_book(bid: int, db: Session = Depends(get_db)): #takes in book id number and retrieves current session
    db_book = db.query(Books).filter(Books.id == bid).first() #queries through book table and find first match to given book id number
    if not db_book: #if no book is found, return error message
        raise HTTPException(status_code=404, detail="Book not Found")
    
    db.delete(db_book) #deletes found book from database
    db.commit() #instructs session to save the book to database
    return{"message":f" Book ID number: {bid}, Title: {db_book.bookname} by {db_book.authorname}, has been deleted"}
    #confirmation message that book id along with title and author name has been deleted from database
    #end of routes-------------------------------------------------------------------------------------